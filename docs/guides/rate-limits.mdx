---
id: rate-limits
title: Rate Limits
sidebar_position: 2
---

# Rate Limits

To ensure fair usage and maintain service quality, our API implements rate limiting on all endpoints.

## Rate Limit Headers

Every API response includes rate limit information in the headers:

```
X-RateLimit-Limit: 1000
X-RateLimit-Remaining: 999
X-RateLimit-Reset: 1609459200
```

- **X-RateLimit-Limit**: Maximum number of requests allowed per window
- **X-RateLimit-Remaining**: Number of requests remaining in the current window
- **X-RateLimit-Reset**: Unix timestamp when the rate limit window resets

<!--## Default Limits

| Plan | Requests per minute | Requests per hour | Requests per day |
|------|---------------------|-------------------|------------------|
| Free | 60 | 1,000 | 10,000 |
| Pro | 300 | 10,000 | 100,000 |
| Enterprise | Custom | Custom | Custom |
-->

## Rate Limit Exceeded

When you exceed the rate limit, you'll receive a `429 Too Many Requests` response:

```json
{
  "error": {
    "code": "rate_limit_exceeded",
    "message": "Rate limit exceeded. Please try again later.",
    "retry_after": 60
  }
}
```

The `retry_after` field indicates the number of seconds to wait before retrying.

## Best Practices

- **Implement exponential backoff** when you receive 429 responses
- **Cache responses** when possible to reduce API calls
- **Monitor rate limit headers** to avoid hitting limits
- **Use webhooks** instead of polling when available

## Example: Handling Rate Limits

```javascript
async function makeRequest(url, options = {}) {
  const response = await fetch(url, options);
  
  if (response.status === 429) {
    const error = await response.json();
    const retryAfter = error.retry_after || 60;
    
    console.log(`Rate limited. Retrying after ${retryAfter} seconds...`);
    await new Promise(resolve => setTimeout(resolve, retryAfter * 1000));
    return makeRequest(url, options); // Retry
  }
  
  return response;
}
```

